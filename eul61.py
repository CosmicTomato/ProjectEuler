#Cyclical figurate numbers

#Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:

#Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
#Square	 		P4,n=n^2	 	1, 4, 9, 16, 25, ...
#Pentagonal	 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
#Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
#Heptagonal	 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
#Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...
#The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

#The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
#Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
#This is the only set of 4-digit numbers with this property.
#Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.




def tri_num_below( x ):
#gets a list of all the triangle numbers up to x

	tri_list = [1]
	n = 1
	while tri_list [ -1 ] < x:
		n += 1
		tri_list.append( ( n * ( n + 1 ) ) // 2 )
	return tri_list

def sq_num_below( x ):
#gets a list of all the square numbers up to x

	sq_list = [1]
	n = 1
	while sq_list [ -1 ] < x:
		n += 1
		sq_list.append( n ** 2 )
	return sq_list

def pent_num_below( x ):
#gets a list of all the pentagonal numbers up to x

	pent_list = [1]
	n = 1
	while pent_list [ -1 ] < x:
		n += 1
		pent_list.append( ( n * ( 3 * n - 1 ) ) // 2 )
	return pent_list


def hex_num_below( x ):
#gets a list of all the hexagonal numbers up to x

	hex_list = [1]
	n = 1
	while hex_list [ -1 ] < x:
		n += 1
		hex_list.append( n * ( 2 * n - 1 ) )
	return hex_list


def hept_num_below( x ):
#gets a list of all the heptagonal numbers up to x

	hept_list = [1]
	n = 1
	while hept_list [ -1 ] < x:
		n += 1
		hept_list.append( ( n * ( 5 * n - 3 ) ) // 2 )
	return hept_list


def oct_num_below( x ):
#gets a list of all the octagonal numbers up to x

	oct_list = [1]
	n = 1
	while oct_list [ -1 ] < x:
		n += 1
		oct_list.append( n * ( 3 * n - 2 ) )
	return oct_list


def cyc_poss( a , b ):
#returns True if last 2 digits of a are the first two digits of b, otherwise returns false

	if int( str( a )[ -2 : ] ) == int( str( b )[ 0 : 2 ] ):
		return True
	else:
		return False

def main():
#solves the desired problem

	d = 10 ** 4
	#only need to get tri,sq,... numbers with 4 digits (i.e. below 10,000)

	tri_list = tri_num_below( d )
	sq_list = sq_num_below( d )
	pent_list = pent_num_below( d )
	hex_list = hex_num_below( d )
	hept_list = hept_num_below( d )
	oct_list = oct_num_below( d )
	#gets lists of all the number types up to first number above 10,000

	type_list = [ [] , [] , [] , tri_list , sq_list , pent_list , hex_list , hept_list , oct_list ]
	#creates list of lists. type_list[ x ] = list of numbers of shape with x sides, e.g. type_list[ x ]=sq_list

	num_type_list = [ [] , [] , [] ]
	for n in range( 3 , 9 ):
		i = 0
		while type_list[ n ][ i ] < 1000:
			i += 1
		num_type_list.append( type_list[ n ][ i : -1 ] )
	#clips off all numbers that aren't 4 digits

	good_sets = []
	num_types = [ 3 , 4 , 5 , 6 , 7 ]

	for oct_num in num_type_list[ 8 ]:
	#cycle must start somewhere, can fix start at oct num since this list is shortest
		for a in num_types:
			for a_num in num_type_list[ a ]:
				if cyc_poss( oct_num , a_num ):
				#i.e. if numbers are part of a potential cycle
					for b in num_types:
						if b != a:
							for b_num in num_type_list[ b ]:
								if cyc_poss( a_num , b_num ):
									for c in num_types:
										if ( c != a ) and ( c != b ):
											for c_num in num_type_list[ c ]:
												if cyc_poss( b_num , c_num ):
													for d in num_types:
														if ( d != a ) and ( d != b ) and ( d != c ):
															for d_num in num_type_list[ d ]:
																if cyc_poss( c_num , d_num ):
																	for e in num_types:
																		if ( e != a ) and ( e != b ) and ( e != c ) and ( e != d ):
																			for e_num in num_type_list[ e ]:
																				if cyc_poss( d_num , e_num ) and cyc_poss( e_num , oct_num ):
																				#at end of cyc, also has to work with start of cycle
																					good_sets.append( set( [ oct_num , a_num , b_num , c_num , d_num , e_num ] ) )

	ans_sets = []
	for good_set in good_sets:
		if good_set not in ans_sets:
			ans_sets.append( good_set )
	return ans_sets
