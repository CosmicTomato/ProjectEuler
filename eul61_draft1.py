#Cyclical figurate numbers

#Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:

#Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
#Square	 		P4,n=n^2	 	1, 4, 9, 16, 25, ...
#Pentagonal	 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
#Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
#Heptagonal	 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
#Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...
#The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

#The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
#Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
#This is the only set of 4-digit numbers with this property.
#Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.




def tri_num_below( x ):
#gets a list of all the triangle numbers up to x

	tri_list = [1]
	n = 1
	while tri_list [ -1 ] < x:
		n += 1
		tri_list.append( ( n * ( n + 1 ) ) // 2 )
	return tri_list

def sq_num_below( x ):
#gets a list of all the square numbers up to x

	sq_list = [1]
	n = 1
	while sq_list [ -1 ] < x:
		n += 1
		sq_list.append( n ** 2 )
	return sq_list

def pent_num_below( x ):
#gets a list of all the pentagonal numbers up to x

	pent_list = [1]
	n = 1
	while pent_list [ -1 ] < x:
		n += 1
		pent_list.append( ( n * ( 3 * n - 1 ) ) // 2 )
	return pent_list


def hex_num_below( x ):
#gets a list of all the hexagonal numbers up to x

	hex_list = [1]
	n = 1
	while hex_list [ -1 ] < x:
		n += 1
		hex_list.append( n * ( 2 * n - 1 ) )
	return hex_list


def hept_num_below( x ):
#gets a list of all the heptagonal numbers up to x

	hept_list = [1]
	n = 1
	while hept_list [ -1 ] < x:
		n += 1
		hept_list.append( ( n * ( 5 * n - 3 ) ) // 2 )
	return hept_list


def oct_num_below( x ):
#gets a list of all the octagonal numbers up to x

	oct_list = [1]
	n = 1
	while oct_list [ -1 ] < x:
		n += 1
		oct_list.append( ( n * ( n + 1 ) ) // 2 )
	return oct_list


def cyc_poss(x):
#returns a list of the possible values for the next number in cyclic series after x (must have same first two digits as x)

	output = []

	out_start = str(x)[-2:]
	#gets the last two digits of x as a string

	for i in range( 0, 100 ):
	#generates all endings 0 to 99

		if i < 10:
			out = out_start + '0' + str( i )

		else:
			out = out_start + str( i )

		out = int( out )
		output.append(out)

	return output




def main():
#solves the desired problem

	import circular_rotations
	#circular_rotations.main(x) returns all circular permutations (of same length, i.e. no leading zeroes) of the digits of x

	d = 10 ** 4
	#only need to get tri,sq,... numbers with 4 digits (i.e. below 10,000)

	tri_list = tri_num_below( d )
	sq_list = sq_num_below( d )
	pent_list = pent_num_below( d )
	hex_list = hex_num_below( d )
	hept_list = hept_num_below( d )
	oct_list = oct_num_below( d )
	#gets lists of all the number types up to first number above 10,000

	for i in oct_list:

		if len( str( i ) ) == 4:
		#i.e. if i has 4 digits

			if str( i )[-2] != '0':
			#rules out the 2nd to last digit of i being 0 (if it is then next number will have leading zero, i.e. be three digits)

				good_list = [ [ 8, i ],[],[] ]
				#will store numbers that could possibly form cyclic set and the type of number that they are (triangle, sq, etc.)

				cyclicals = cyc_poss( i )
				#gets the possible values for the next number in a cyclic series starting with i

				for y in cyclicals:
				#checks if any of the cyclical possiblities is in any of the other lists. if it is, adds it to the good list and appends the number of sides of the shape to the "out" list

#BROKEN					if str( y )[-2] != '0':
					#rules out the 2nd to last digit of y being 0 (if it is then next number will have leading zero, i.e. be three digits)


						if y in tri_list:
							good_list[1].append([3,y])

						elif y in sq_list:
							good_list[1].append([4,y])

						elif y in pent_list:
							good_list[1].append([5,y])

						elif y in hex_list:
							good_list[1].append([6,y])

						elif y in hept_list:
							good_list[1].append([7,y])
#TEST
				print('good_list=',good_list)
#TEST

				if len( good_list ) >= 1:
				#i.e. if at least one good cyclical found

					for k in range( 0, len(good_list[1]) ):

						cyclicals = cyc_poss( good_list[1][2*k+1] )

#TEST
#TEST						print('k=',good_list[k])
#TEST
						for y in cyclicals:
						#checks if any of the cyclical possiblities is in any of the other lists. if it is, adds it to the good list and appends the number of sides of the shape to the "out" list

#BROKEN							if str( y )[-2] != '0':
							#rules out the 2nd to last digit of y being 0 (if it is then next number will have leading zero, i.e. be three digits)


								if y in tri_list and good_list[1][2*k+1] != 3:
								#the != part prevents adding the same number again
									good_list[2].append([3,y])

								elif y in sq_list and good_list[1][2*k+1] != 4:
									good_list[2].append([4,y])

								elif y in pent_list and good_list[1][2*k+1] != 5:
									good_list[2].append([5,y])

								elif y in hex_list and good_list[1][2*k+1] != 6:
									good_list[2].append([6,y])

								elif y in hept_list and good_list[1][2*k+1] != 7:
									good_list[2].append([7,y])


#TEST
					print('good_list=',good_list)
#TEST

